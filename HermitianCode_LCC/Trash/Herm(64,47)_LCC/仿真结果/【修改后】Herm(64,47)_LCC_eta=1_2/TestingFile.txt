一. 测试所用变量说明：

1. epcount1	//传输中发生的错误符号数
2. epcount2	//译码后的错误符号数
3. testCount1[test_vec_num]	//存放每个测试向量在传输中发生的错误符号数
4. testCount2[test_vec_num]	//存放每个测试向量在译码后发生的错误符号数
5. (testCount1[i] - testCount1_com) = testCount1_uncom //表征的是对应第i个测试向量没有翻对，反而翻错的符号数。
6. listNum //分解操作中，对应每个testVector对应的分解成功的条目数


二. Note
 1. 在（64，47）HermCode中，sakata译码算法是硬判决译码算法，所以它的译码能力由最小距离决定，τ=[(n-k-g)/2]=5


三. 测试说明（for 陈老师）
**备注：假设是，HermCode(64,47) 的sakata算法的译码能力为τ=[(n-k-g)/2]=5，与GS(m=1,η=0）的译码能力相同。
**以下测试都是在“只要分解步骤后出现了完整的信息选项，那么就认为可以译出，暂时不考虑分解输出是否选错”的背景之下。

测试条件一： LCC(η=1)算法，至少能译出5个错误。所以测试是否有testVector是错误数5个以下，却译不出来的情况。
结果：      SNR=（3，5）、seqNum=10000的情况下，出现了testVector的错误数少于5，却译不出来的情况，但这一帧的译码是正确的(即epcount2=5)。SNR=5时出现此情况更为频繁。即程序有错。
